<!DOCTYPE html>
<html>
<head>
	<!-- General Meta Tags -->
	<title>Habit Tracker</title>
	<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=no">
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="description" content="A calendar for tracking your habits in order to visually see your consistency and progress and encourage dedication.">

	<!-- Style -->
	<link rel="stylesheet" href="./static/style.css">

	<!-- Scripts -->
	<script src="./static/js/jquery.min.js"></script>
	<script src="./static/js/jquery.ba-throttle-debounce.min.js"></script>
</head>
<body>

	<div id="calendarContainer">
		<div id="popup">
			
		</div>
	</div>


	<!-- Scripts -->
	<!-- Cookie Handling -->
	<script type="text/javascript">
		// Returns an object based on all the cookies
		function get_cookie_object() {
			let cookie_obj = {};
			let cookie_strings = document.cookie.split(';');
			let re = /\s*(.+)=(.*)/;
			for(let i=0; i<cookie_strings.length; i+=1) {
				let str = cookie_strings[i];
				let match = re.exec(str);
				if(match) {
					let key = match[1];
					let val = match[2];
					cookie_obj[key] = decodeURIComponent(val);
				}
				else {
					console.warn(`get_cookie_object: unable to parse cookie_string "${str}"`);
				}
			}
			return cookie_obj;
		}

		function save_cookie(key, value) {
			document.cookie = `${key}=${encodeURIComponent(value)}; expires=2147483647`;
			console.log(`${key}=${encodeURIComponent(value)}; expires=2147483647`);
		}
	</script>

	<!-- SVG Generator -->
	<script type="text/javascript">
		/* SVG ELEMENT GENERATORS
		========================= */
		function svg_elem(tag, attrs) {
			let elem = document.createElementNS('http://www.w3.org/2000/svg', tag);
			Object.entries(attrs).forEach(entry => {
				let key = entry[0];
				let val = entry[1];
				if(val !== null && val !== undefined)
					elem.setAttributeNS(null, key, val);
			});
			return elem;
		}

		function svg_svg(id, width, height, other_attrs) {
			let attrs = {
				'id': id,
				'width': width,
				'height': height,
			};
			if(other_attrs)
				Object.assign(attrs, other_attrs);
			return svg_elem('svg', attrs);
		}

		function svg_g(id, other_attrs) {
			let attrs = {
				'id': id,
			};
			if(other_attrs)
				Object.assign(attrs, other_attrs);
			return svg_elem('g', attrs);
		}


		/* CONTEXT BASED SVG-GENERATOR UTILITY
		====================================== */
		class SvgGenerator {
			/* CONSTRUCTOR
			-------------- */
			constructor(id, width, height) {
				this._svg = svg_svg(id, width, height);
				this._context = {
					'elem': this._svg,
					'x': 0,
					'y': 0,
				};
				this._context_stack = [this._context];
			}

			/* GETTERS
			---------- */
			get svg() {
				return this._svg;
			}
			get context() {
				return this._context;
			}
			get context_elem() {
				if(!this._context)
					return null;
				return this._context.elem;
			}
			get context_x() {
				if(!this._context)
					return null;
				return this._context.x;
			}
			get context_y() {
				if(!this._context)
					return null;
				return this._context.y;
			}
			get context_id() {
				if(!this._context)
					return null;
				return this._context.elem.getAttribute('id');
			}

			/* QUERIES
			---------- */
			at_base_layer() {
				return this._context_stack.length === 1;
			}

			/* CONTEXT MANIPULATION
			----------------------- */
			new_layer(id, x=0, y=0, other_attrs) {
				let g = svg_g(id, other_attrs);
				let new_context = {
					'elem': g,
					'x': x + this._context.x,
					'y': y + this._context.y,
				}
				this._context = new_context;
				this._context_stack.push(new_context);
				return g;
			}

			end_layer() {
				if(this.at_base_layer())
					return false;
				let popped_elem = this._context_stack.pop().elem;
				this._context = this._context_stack[this._context_stack.length - 1];
				// Append the finished layer to the parent layer
				this._context.elem.appendChild(popped_elem);
				return true;
			}

			flush() {
				while(this.end_layer());
			}

			/* GENERATION FUNCTIONS
			----------------------- */
			add_elem(tag, attrs) {
				let elem = svg_elem(tag, attrs);
				this._context.elem.appendChild(elem);
				return elem;
			}

			add_circle(id, x, y, r, other_attrs) {
				let attrs = {
					'id': id,
					'cx': x + this._context.x,
					'cy': y + this._context.y,
					'r': r,
				};
				if(other_attrs)
					Object.assign(attrs, other_attrs);
				return this.add_elem('circle', attrs);
			}

			add_rect(id, x, y, width, height, other_attrs) {
				let attrs = {
					'id': id,
					'x': x + this._context.x,
					'y': y + this._context.y,
					'width': width,
					'height': height,
				};
				if(other_attrs)
					Object.assign(attrs, other_attrs);
				return this.add_elem('rect', attrs);
			}

			add_line(id, x1, y1, x2, y2, other_attrs) {
				let attrs = {
					'id': id,
					'x1': x1 + this._context.x,
					'y1': y1 + this._context.y,
					'x2': x2 + this._context.x,
					'y2': y2 + this._context.y,
				};
				if(other_attrs)
					Object.assign(attrs, other_attrs);
				return this.add_elem('line', attrs);
			}

			add_slice(id, cx, cy, r, start_angle, theta, other_attrs) {
				// Full_circle case
				if(theta >= 2*Math.PI) {
					return this.add_circle(id, cx, cy, r, other_attrs);
				}

				// Slice case (using arc)
				cx += this._context.x;
				cy += this._context.y;
				// Get the start and end points for the arc
				let x1 = cx + r*Math.sin(start_angle);
				let y1 = cy - r*Math.cos(start_angle);
				let x2 = cx + r*Math.sin(start_angle + theta);
				let y2 = cy - r*Math.cos(start_angle + theta);

				let large_arc = theta > Math.PI ? 1 : 0; // Determines whether to take the larger arc, only 1 when theta > 180
				let sweep = 1; // Determines the direction around the circle to travel, always 1

				// Create path for slice
				let slice_path = `M ${cx} ${cy} L ${x1} ${y1} A ${r} ${r} 0 ${large_arc} ${sweep} ${x2} ${y2} Z`;
				// Consctruct element
				let attrs = {
					'id': id, 
					'd': slice_path,
				}
				if(other_attrs)
					Object.assign(attrs, other_attrs);
				return this.add_elem('path', attrs);
			}

			add_text(id, x, y, text, other_attrs) {
				let attrs = {
					'id': id,
					'x': x + this._context.x,
					'y': y + this._context.y,
				}
				if(other_attrs)
					Object.assign(attrs, other_attrs);
				let elem = svg_elem('text', attrs);
				elem.textContent = text;
				this._context.elem.appendChild(elem);
				return elem;
			}

			add_use(id, href) {
				let attrs = {
					'id': id,
				}
				let elem = this.add_elem('use', attrs);
				elem.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', `#${href}`);
				return elem;
			}
		}
	</script>

	<!-- Habit Tracker / Database -->
	<script type="text/javascript">
		/* CONSTANTS
		------------ */
		const max_habits = 16;
		const max_years = 10;

		class HabitTracker {
			/* CONSTRUCTOR
			-------------- */
			constructor() {
				// Can hold 16 habit objects, which contain a `name` entry and a `color` entry
				this.habits = [];
				// Tracker contains entry for each year with a tracked date, and within that a year object
				// Year object contains entry for each day with a tracked habit in the form 'mm-dd'
				// Each tracked day has a 16-bit bit-map of indexed habits (serialized as 4-digit hex)
				// Will look like `mm-dd:00;` (THERE MAY BE AN ISSUE WITH NULL CHAR WITH THIS, MUST LOOK UP)
				this.tracker = {}; 
			}

			/* GETTERS
			---------- */
			get num_habits() {
				return this.habits.length;
			}

			static get_date_key(month, date) {
				return `${month < 10 ? '0'+month : month}-${date < 10 ? '0'+date : date}`;
			} 

			/* Accessors
			------------ */
			get_date_entry(date_obj) {
				let year_entry = this.tracker[date_obj.getFullYear()];
				if(year_entry === undefined)
					return null;

				let date_key = HabitTracker.get_date_key(date_obj.getMonth(), date_obj.getDate());
				let date_entry = year_entry[date_key];
				if(date_entry === undefined)
					return null;
				return date_entry;
			}

			/* Modifiers
			------------ */
			add_habit(name, color) {
				if(this.habits.length >= max_habits) {
					console.warn(`CANNOT ADD HABIT: reached maximum of ${max_habits}`);
					return false;
				}
				this.habits.push({'name': name, 'color': color});
				return true;
			}
			remove_habit(index) {
				if(index >= this.habits.length) {
					console.warn(`CANNOT REMOVE HABIT: index:${index} is out of bounds`);
					return false;
				}
				this.habits.splice(index, 1);
				// Adjust ALL tracked habits to match bit-flag reperesentation
				let shift_mask = ~0 << (index+1);
				let nonshift_mask = ~shift_mask >> 1;
				for(let year_id in this.tracker) {
					let year_entry = this.tracker[year_id];
					for(let date_id in year_entry) {
						let date_entry = year_entry[date_id];
						date_entry = ((date_entry&shift_mask) >> 1) | (date_entry&nonshift_mask);
						year_entry[date_id] = date_entry;
					}
				}
				return true;
			}

			add_tracked_habit(year, month, date, habit_index, calendar=null) {
				if(habit_index >= this.habits.length) {
					console.warn(`CANNOT TRACK HABIT: index:${habit_index} is out of bounds`);
					return false;
				}
				// If year entry doesn't exist, create it
				let year_entry = this.tracker[year];
				if(year_entry === undefined) {
					year_entry = {};
					this.tracker[year] = year_entry;
				}
				// Get date key for date entry
				let date_key = HabitTracker.get_date_key(month, date);
				// If habit is already tracked, return false
				if(year_entry[date_key] & (1<<habit_index))
					return false;
				// Add the tracked habit to the bit-map (undefined acts like 0)
				year_entry[date_key] |= (1<<habit_index);

				// Change the tracked date on the calendar, if possible
				if(calendar !== null) {
					if(calendar.month === month && calendar.year === year) {
						let date_circle = $(`#day${date}`);
						if(date_circle) {
							let slice = $(date_circle).children('.date-slice')[habit_index];
							$(slice).addClass('date-slice-active');
						}
					}
				}

				return true;
			}

			remove_tracked_habit(year, month, date, habit_index, calendar=null) {
				// If year entry doesn't exist, return false
				let year_entry = this.tracker[year];
				if(year_entry === undefined)
					return false;
				// Get date key for date entry
				let date_key = HabitTracker.get_date_key(month, date);
				// If habit is not tracked, return false
				if(!(year_entry[date_key] & (1<<habit_index)))
					return false;
				// Remove the tracked habit form the bit-map
				year_entry[date_key] &= ~(1<<habit_index);

				// Change the tracked date on the calendar, if possible
				if(calendar !== null) {
					if(calendar.month === month && calendar.year === year) {
						let date_circle = $(`#day${date}`);
						if(date_circle) {
							let slice = $(date_circle).children('.date-slice')[habit_index];
							$(slice).removeClass('date-slice-active');
						}
					}
				}

				return true;
			}

			/* Serialization / Deserialization
			---------------------------------- */
			// Serialize directly to JSON
			serialize_habits() {
				return JSON.stringify(this.habits);
			}
			// Deserialize directly from JSON
			deserialize_habits(cookie_obj, use_alt) {
				// Set get proper habits_string appropriate to use_alt
				let habits_string = use_alt ? cookie_obj['~habits'] : cookie_obj['habits'];
				try {
					let deserialized_habits = JSON.parse(habits_string);
					return deserialized_habits;
				}
				catch(err) {
					return null;
				}
			}

			// Return a object with year_ids mapped to serialized year_entries instead of 
			serialize_tracker() {
				// Trim years to only allow the latest `max_years` amount to be serialized
				let year_keys = Object.keys(this.tracker).sort().reverse().slice(0,max_years);
				// Serialize the years
				let serialized_tracker = {};
				for(let i=0; i<year_keys.length; i+=1) {
					let year_key = year_keys[i];
					let serialized_year_key = `y${year_key}`;
					serialized_tracker[serialized_year_key] = this.serialize_year_entry(this.tracker[year_key]);
				}
				return serialized_tracker;
			}
			serialize_year_entry(year_entry) {
				let serialized = [];
				for(let date_key in year_entry) {
					let serialized_date = this.serialize_date_entry(date_key, year_entry[date_key]);
					serialized.push(serialized_date);
				}
				return serialized.join('');
			}
			serialize_date_entry(date_key, date_entry) {
				return `${date_key}:${date_entry.toString(16)},`;
			}

			// Deserialize tracker
			deserialize_tracker(cookie_obj, use_alt) {
				let deserialized_tracker = {};
				// Set the regex for key information
				let re = use_alt ? /~y(\d{4})/ : /y(\d{4})/;
				for(let key in cookie_obj) {
					let match = re.exec(key);
					if(match) {
						let year_id = match[1];
						let serialized_entry = cookie_obj[key];
						deserialized_tracker[year_id] = this.deserialize_year_entry(serialized_entry);
					}
				}
				return deserialized_tracker;
			}
			deserialize_year_entry(serialized) {
				let year_entry = {};
				let re = /(\d\d-\d\d):([abcdef\d]{1,4}),/g;
				let match;
				while(match = re.exec(serialized)) {
					let date_key = match[1];
					let date_entry = parseInt(match[2], 16);
					year_entry[date_key] = date_entry;
				}
				return year_entry;
			}

			/* Saving and Loading Cookies
			----------------------------- */
			save_to_cookies(cookie_obj) {
				// Serialize habits and tracker
				let serialized_habits = this.serialize_habits();
				let serialized_tracker = this.serialize_tracker();
				// If use_alt exists and is set to 0, make alt keys: prefix cookie keys with "~"
				let use_alt_cookie = cookie_obj['use_alt'];
				let use_alt = use_alt_cookie === '0';
				// Save habits
				save_cookie(use_alt ? '~habits' : 'habits', serialized_habits);
				// Save tracker year_entries
				for(let key in serialized_tracker) {
					save_cookie(use_alt ? `~${key}` : key, serialized_tracker[key]);
				}
				// Toggle the `use_alt` tracker
				save_cookie('use_alt', use_alt ? 1 : 0);
			}

			load_from_cookies(cookie_obj) {
				// Get object with current cookies
				// if(!cookie_obj)
				// 	cookie_obj = get_cookie_object();
				// If use_alt is set to 1, cookie keys prefixed with "_"
				let use_alt_cookie = cookie_obj['use_alt'];
				let use_alt = use_alt_cookie === '1';
				// Load habits
				let deserialized_habits = this.deserialize_habits(cookie_obj, use_alt);
				// If habits fails to deserialize, don't even attempt to load tracker, return false as failure
				if(deserialized_habits != null)
					this.habits = deserialized_habits;
				else
					return false;
				// Load tracker
				this.tracker = this.deserialize_tracker(cookie_obj, use_alt);
				return true;
			}
		}
	</script>

	<!-- Calendar Layout -->
	<script type="text/javascript">
		class Calendar {
			/* CONSTRUCTOR
			-------------- */
			constructor(habit_tracker) {
				this.habit_tracker = habit_tracker;
				let now = new Date(Date.now());
				this.date = now.getDate();
				this.focus_date = this.date;
				this.month = now.getMonth();
				this.year = now.getFullYear();
			}

			/* GETTERS
			---------- */
			get date_obj() {
				if(this.focus_date === null)
					return null;
				return new Date(this.year, this.month, this.focus_date);
			}

			/* VIEW CHANGES
			--------------- */
			set_focus_date(new_date) {
				// Remove class from old circle
				if(this.focus_date !== null) {
					let old_focus_circle = $(`#day${this.focus_date}`);
					$(old_focus_circle).removeClass('focus-date');
				}
				// Set new focus date and find new circle
				this.focus_date = new_date;
				if(this.focus_date !== null) {
					let new_focus_circle = $(`#day${this.focus_date}`);
					$(new_focus_circle).addClass('focus-date');
				}
			}

			set_month(new_month, new_year) {
				this.year = new_year;
				this.month = new_month % 12;
				// If returning to current month, set date to today, otherwise set to null
				let now = new Date(Date.now());
				if(now.getMonth() === this.month)
					this.date = now.getDate();
				else
					this.date = null;
				// Set focus date to current date
				this.focus_date = this.date;
				// REFRESH CALENDAR VIEW
				$(document).trigger('calendar:refresh');
			}

			shift_month_forward() {
				if(this.month === 11) {
					this.month = 0;
					this.year += 1;
				}
				else {
					this.month += 1;
				}
				// If returning to current month, set date to today, otherwise set to null
				let now = new Date(Date.now());
				if(now.getMonth() === this.month)
					this.date = now.getDate();
				else
					this.date = null;
				// Set focus date to current date
				this.focus_date = this.date;
				// REFRESH CALENDAR VIEW
				$(document).trigger('calendar:refresh');
			}
			shift_month_backward() {
				if(this.month === 0) {
					this.month = 11;
					this.year -= 1;
				}
				else {
					this.month -= 1;
				}
				// If returning to current month, set date to today, otherwise set to null
				let now = new Date(Date.now());
				if(now.getMonth() === this.month)
					this.date = now.getDate();
				else
					this.date = null;
				// Set focus date to current date
				this.focus_date = this.date;
				// REFRESH CALENDAR VIEW
				$(document).trigger('calendar:refresh');
			}

			/* RENDERING
			------------ */
			generate_calendar(gen) {
				// CONSTANTS
				const date_radius = 40;
				const date_padding = 16;
				const today_radius = 45;
				const focus_radius = 50;

				const header_dy = 20;
				const header_height = 60;
				const half_header_height = header_height/2;
				const header_width = 7*2*date_radius + 6*2*date_padding; // Width of calendar dates
				const header_padding = 6;
				const header_corner_radius = 20;
				const header_month_shift_radius = 16;

				const alpha = 0.8;
				const background_color = 'rgba(255,255,255,0.25)';
				const stroke_and_text = '#888';
				const light_stroke = '#aaa';
				const focus_stroke_and_text = '#444'
				// ---------

				// Get day of the week for first of the month
				let first_day = new Date(this.year, this.month, 1).getDay();
				// Get number of days (day=0 makes it show the last day of the current month, sinche month+1)
				let num_days = new Date(this.year, this.month+1, 0).getDate();
				// Get number of rows of dates
				let num_rows = 1 + Math.ceil((num_days - (7 - first_day))/7);
				// Get the year_entry from habit_tracker
				let year_entry = this.habit_tracker.tracker[this.year];

				// Start generating
				gen.new_layer(null, 0, 0, {'style': 'pointer-events: none;'});

				// Generate month header
				gen.new_layer(null, 0, -(header_height + header_dy));
				// Header background scrim
				// gen.add_rect(null, 0, 0, header_width, header_height, 
				// 	{'fill': background_color, 'rx': header_corner_radius, 'ry': header_corner_radius});
				// Get month name and add it
				let temp_date_obj = new Date(this.year, this.month);
				let month_name = temp_date_obj.toLocaleString('en-us', { month: 'long' });
				gen.add_text('monthHeader', header_width/2, half_header_height, `${month_name} ${this.year.toString().substr(2)}`, 
					{'class': 'text-vert-central', 'fill': stroke_and_text, 'text-anchor': 'middle',});
				// Month shifting buttons
				let button_size = header_height - 2*header_padding;
				// Left shift
				let month_left_shift = gen.add_rect(null, header_padding, header_padding, button_size, button_size, 
					{'class': 'hover-show', 'rx': header_month_shift_radius, 'ry': header_month_shift_radius, 'fill': background_color, 'style': 'cursor: pointer;'});
				gen.add_text('monthShift', header_padding+(button_size/2)-1, half_header_height, '<', 
					{'class': 'text-vert-central', 'fill': stroke_and_text, 'text-anchor': 'middle',});
				// Right shift
				let month_right_shift = gen.add_rect(null, header_width-header_padding-button_size, header_padding, button_size, button_size, 
					{'class': 'hover-show', 'rx': header_month_shift_radius, 'ry': header_month_shift_radius, 'fill': background_color, 'style': 'cursor: pointer;'});
				gen.add_text('monthShift', header_width-(header_padding+(button_size/2))+1, half_header_height, '>', 
					{'class': 'text-vert-central', 'fill': stroke_and_text, 'text-anchor': 'middle',});
				gen.end_layer();

				// Month shift button handlers
				$(month_left_shift).click((function() {
					this.shift_month_backward();
				}).bind(this));
				$(month_right_shift).click((function() {
					this.shift_month_forward();
				}).bind(this));

				// Generate generic date circle

				// Generate date circles
				let cur_date = 1;
				for(let i = 0; i<num_rows; i += 1) {
					let row_center = date_radius + 2*i*(date_radius + date_padding);
					gen.new_layer(`row${i}`, 0, row_center, {'fill':'transparent'});
					let j = i === 0 ? first_day : 0;
					while(j<7 && cur_date <= num_days) {
						let xc = date_radius + 2*j*(date_radius + date_padding);
						let is_focus = cur_date === this.focus_date;
						// Date layer
						let date_g = gen.new_layer(`day${cur_date}`, xc, 0, 
							{'class':`date-circle ${is_focus ? 'focus-date' : ''}`,});

							// Background circle
							gen.add_circle(null, 0, 0, date_radius, 
								{'fill': background_color, 'stroke': 'transparent !important'});

							// Determine slices to show from habit tracker
							if(year_entry && this.habit_tracker.num_habits) {
								let date_key = `${this.month < 10 ? '0'+this.month : this.month}-${cur_date < 10 ? '0'+cur_date : cur_date}`;
								let date_entry = year_entry[date_key];
								let slice_theta = 2*Math.PI/this.habit_tracker.num_habits;
								for(let k=0; k<this.habit_tracker.num_habits; k+=1) {
									let habit_color = this.habit_tracker.habits[k].color;
									gen.add_slice(null, 0, 0, date_radius-0.5, k*slice_theta, slice_theta, 
										{'fill': habit_color, 'class': `date-slice ${date_entry & (1<<k) ? 'date-slice-active' : ''}`});
								}
							}

							// If is today's date, add an extra embelishing circle
							if(cur_date === this.date) {
								gen.add_circle(null, 0, 0, today_radius, 
									{'class': 'use-stroke', 'stroke-width': 1});
							} 
							// Add focus date embelishing circle (only showing if date is focused)
							gen.add_circle(null, 0, 0, focus_radius, 
									{'class': 'use-stroke focus-circle', 'stroke-width': 1});
							// Draw circle and text
							gen.add_circle(null, 0, 0, date_radius, 
								{'class': 'use-stroke', 'stroke-width': 1});
							gen.add_text(null, 0, 0, cur_date, {'class': 'text-vert-central', 'text-anchor': 'middle',})
						gen.end_layer();

						// Add click handler for date
						(function(date) {
							$(date_g).click((function(e) {
								// Always stop click propogation
								e.stopPropagation();
								// Change focus
								this.set_focus_date(date);
								// Open popup
								$(document).trigger('calendar:open_popup');
							}).bind(this));
						}).bind(this)(cur_date);

						j += 1;
						cur_date += 1;
					}
					gen.end_layer();
				}
				gen.end_layer();
			}

			generate_habit_viewer(gen) {
				// CONSTANTS
				const viewer_radius = 80;
				const habit_text_x = -130;
				const habit_text_y = -80;
				const habit_text_x_padding = 6;
				const habit_text_length = 140;
				const habit_text_underline_padding = 10;
				const habit_focus_circle_radius = 4;
				const habit_focus_circle_radius_coeff = 0.65;

				const alpha = 0.8;
				const stroke_and_text = '#888';
				// ---------

				gen.new_layer(null, viewer_radius, 0, {'style': `opacity: ${alpha}; pointer-events: none;`});
				// Generate slices and habit text and line
				if(this.habit_tracker.num_habits) {
					let slice_theta = 2*Math.PI/this.habit_tracker.num_habits;
					for(let k=0; k<this.habit_tracker.num_habits; k+=1) {
						let habit = this.habit_tracker.habits[k]
						// New layer for slice
						gen.new_layer('habitViewerHabit', 0, 0);
						// Generate slice
						gen.add_slice('habitSlice', 0, 0, viewer_radius-0.5, k*slice_theta, slice_theta, 
							{'fill': habit.color});
						// Generate text
						gen.new_layer(`habitText${k}`, 0, 0, {'class': 'habit-text'});
						gen.add_text(null, habit_text_x, habit_text_y, habit.name, 
							{'text-anchor': 'end', 'fill': stroke_and_text});
						// Generate line under text
						let slice_point_angle = (k*slice_theta) + (slice_theta/2);
						let slice_point_x = 0;
						let slice_point_y = 0;
						// If not full circle, calculate real slice point
						if(this.habit_tracker.num_habits > 1) {
							slice_point_x = habit_focus_circle_radius_coeff*viewer_radius*Math.sin(slice_point_angle);
							slice_point_y = -habit_focus_circle_radius_coeff*viewer_radius*Math.cos(slice_point_angle);
						}
						let line_attrs = {
							'd': `M ${habit_text_x + habit_text_x_padding + gen._context.x - habit_text_length} ${habit_text_y + gen._context.y + habit_text_underline_padding} l ${habit_text_length} 0 L ${slice_point_x + gen._context.x} ${slice_point_y + gen._context.y}`,
							'stroke': stroke_and_text,
							'fill': 'transparent',
						};
						gen.add_elem('path', line_attrs);
						// Redundant line-end circle for overlapping
						gen.add_circle(null, slice_point_x, slice_point_y, habit_focus_circle_radius, 
							{'fill': habit.color, 'stroke': stroke_and_text, 'stroke-width': 1});
						// End layer
						gen.end_layer();

						// Generate small circle for end of line (always showing)
						gen.add_circle(null, slice_point_x, slice_point_y, habit_focus_circle_radius, 
							{'fill': habit.color, 'stroke': stroke_and_text, 'stroke-width': 1});

						// End layer
						gen.end_layer();
					}
				}

				// Draw circle
				gen.add_circle(null, 0, 0, viewer_radius, 
					{'fill': 'transparent', 'stroke': stroke_and_text, 'stroke-width': 1});

				// Generate use tags for habitText
				for(let k=0; k<this.habit_tracker.num_habits-1; k+=1) {
					gen.add_use(null, `habitText${k}`);
				}

				gen.end_layer();
			}

			generate_habit_list(gen) {
				// CONSTANTS
				const list_width = 240;
				const header_height = 10;
				const header_underline_padding = 8;

				const entry_height = 24;
				const half_entry_height = entry_height/2;
				const entry_margin = 6;
				const entry_padding = 6;
				const entry_border_radius = 4;

				const alpha = 0.8;
				const stroke_and_text = '#888';
				const light_stroke = '#bbb';
				// ---------

				// Main group layer
				gen.new_layer('habitListContainer', 0, 0);

				// Header
				gen.new_layer('habitListHeader', 0, header_height);
				gen.add_text(null, 0, 0, 'Habits', {/*'dominant-baseline': 'bottom'*/});
				gen.add_line(null, 0, header_underline_padding, list_width, header_underline_padding);
				gen.end_layer();

				// List layer
				gen.new_layer('habitList', 0, header_height + header_underline_padding + entry_margin);
				let current_y = 0;

				// Add habit button 
				if(this.habit_tracker.num_habits < max_habits) {
					// New layer
					let add_habit_button = gen.new_layer('addHabitButton', 0, 0);
					// Button rect
					gen.add_rect(null, 0, 0, list_width, entry_height, 
						{'class': 'hover-show', 'rx': entry_border_radius, 'ry': entry_border_radius,});
					// Add habit text
					gen.add_text(null, entry_padding, half_entry_height, '+ Add Habit', 
						{'class': 'text-vert-central'});
					// End layer
					gen.end_layer();

					// Increment current_y
					current_y += entry_height + entry_margin;

					// Set handler for button
					$(add_habit_button).click(function() {
						$(document).trigger('calendar:add_habit');
					});
				}


				// Habit edit handler generator
				let habit_edit_handler_gen = function(habit_index) {
					return function() {
						$(document).trigger('calendar:edit_habit', habit_index);
					}
				};
				// Habits
				for(let k=0; k<this.habit_tracker.num_habits; k+=1) {
					let habit = this.habit_tracker.habits[k];
					// New layer
					let list_entry = gen.new_layer(null, 0, current_y, 
						{'class': 'habit-list-entry'});
					$(list_entry).click(habit_edit_handler_gen(k));
					// Underline
					/*gen.add_line(null, entry_border_radius, entry_height-1, list_width, entry_height,
						{'style': `stroke: ${habit.color};`});*/
					gen.add_line(null, entry_border_radius, entry_height, list_width, entry_height);
					// Color rect
					gen.add_rect(null, 0, 0, entry_height, entry_height, 
						{'fill': habit.color, 'rx': entry_border_radius, 'ry': entry_border_radius,});
					// Habit name
					gen.add_text(null, entry_height + entry_padding, half_entry_height, habit.name,
						{'class': 'text-vert-central',});
					// End layer
					gen.end_layer();

					// Increment current_y
					current_y += entry_height + entry_margin;
				}
			}
		}
	</script>

	<!-- Main -->
	<script type="text/javascript">
		// STATICS
		let habit_colors = [
			'#BAE1FF', // pastel blue
			'#92B6FF', // normal blue
			'#BAA6FF', // normal purple
			'#E1C9FF', // pastel purple

			'#A0FFFC', // baby blue
			'#91FDDE', // turqoise
			'#BFFFBA', // pastel green
			'#CEFF86', // lime green

			'#FFFFBA', // pastel yellow
			'#FFF38C', // normal yellow
			'#FFE2BA', // pastel orange
			'#FFC88A', // normal orange

			'#FFCBBA', // pastel red
			'#FCAA9C', // normal red
			'#FFA6C5', // fuschia 
			'#FFCCE2', // pink
		];

		class Main {
			/* Constructor
			-------------- */
			constructor() {
				this.habit_tracker = new HabitTracker();
				this.calendar = new Calendar(this.habit_tracker);

				// Debounced call to save
				this.debounced_save = $.debounce(1000, this.save);

				// Persistent values
				this.persistent = {
					'last_date_checked': new Date(0),
				}

				// Settings
				this.settings = {
					'auto_checklist_time': 1633,// Default to 7pm
				};

				// Aync timing vars
				this.timers = {
					'auto_checklist': null,
					'today_date_change': null,
				}
			}

			/* SAVING AND LOADING
			--------------------- */
			load() {
				let cookie_obj = get_cookie_object();
				this.habit_tracker.load_from_cookies(cookie_obj);
				this.load_persistent_values(cookie_obj);
			}
			save() {
				let cookie_obj = get_cookie_object();
				this.habit_tracker.save_to_cookies(cookie_obj);
				this.save_persistent_values();
			}

			save_persistent_values() {
				save_cookie('persistent', JSON.stringify(this.persistent));
			}
			load_persistent_values(cookie_obj) {
				let values_from_cookies = cookie_obj['persistent'];
				try {
					let deserialized = JSON.parse(values_from_cookies);
					this.persistent = deserialized;
					// Adjust specific values for type
					this.persistent.last_date_checked = new Date(this.persistent.last_date_checked);
					return true;
				}
				catch(err) {
					console.log('FAILED: load_persistent_values(): parsing values_from_cookies');
					return false;
				}
			}
			/* ------------------ */

			generate_site() {
				// Timing 
				let time_start = Date.now();

				let gen = new SvgGenerator('calendar', 1050, 800);

				gen.new_layer(null, 10, 120);
					this.calendar.generate_calendar(gen);
					gen.end_layer();
				gen.new_layer(null, 800, 120);
					this.calendar.generate_habit_viewer(gen);
					gen.new_layer(null, 0, 100);
						this.calendar.generate_habit_list(gen);
				gen.flush();

				let container = $('#calendarContainer');
				// Get old calendar svg if it exists
				let old_calendar = $('#calendar');
				// Append new calendar
				container.append(gen.svg);
				// Delete old calendar if it exists
				if(old_calendar.length > 0) {
					old_calendar.remove();
				}

				// Set calendar handlers

				// Timing
				let time_end = Date.now();
				let time_to_process = (time_end - time_start)/1000;
				console.log(`Calendar rendered in: ${time_to_process}s`);
			}

			initiate_handlers() {
				/*// Focus resetting for container clicks (REMEMBER TO STOP PROPOGATION ON CLICK HANDLERS)
				$('#calendarContainer').click((function() {
					console.log('pee');
					// Reset focus_date
					this.calendar.set_focus_date(null);
				}).bind(this));*/

				// Refresh event
				$(document).on('calendar:refresh', (function() {
					this.generate_site();
				}).bind(this)); // Bind to this

				// Add-habit event
				$(document).on('calendar:add_habit', (function() {
					this.add_habit_popup();
				}).bind(this));
				// Edit-habit event
				$(document).on('calendar:edit_habit', (function(e, habit_index) {
					this.edit_habit_popup(habit_index);
				}).bind(this));

				// Open-popup event
				$(document).on('calendar:open_popup', (function() {
					this.habit_checklist_popup();
				}).bind(this));
				// Close-popup event
				$(document).on('calendar:close_popup', (function() {
					this.close_popup();
				}).bind(this)); // Bind to this

				// Focus event
				// Re-initiate this.date_checklist_popup_timer
				$(window).focus((function() {
					this.set_intervals();
				}).bind(this));
				// Blur event 
				// Stop this.date_checklist_popup_timer
				$(window).blur((function() {
					this.stop_intervals();
				}).bind(this));
			}

			// AUTO_CHECKLIST
			start_auto_checklist(interval_time=60000) {
				if(this.timers.auto_checklist !== null)
					clearInterval(this.timers.auto_checklist);
				this.auto_checklist_handler();
				let timer = setInterval(this.auto_checklist_handler.bind(this), interval_time);
				this.timers.auto_checklist = timer;
				return timer;
			}
			stop_auto_checklist() {
				if(this.timers.auto_checklist !== null) {
					clearInterval(this.timers.auto_checklist);
					this.timers.auto_checklist_handler = null;
				}
			}
			auto_checklist_handler() {
				// Persistent values to track changes for
				let old_last_date_checked = this.persistent.last_date_checked;

				// Only compute if there are currently habits
				if(this.habit_tracker.num_habits > 0) {
					let should_check = true;

					let now = new Date(Date.now());
					// Determine if the last check should be done for today or yesterday
					let check_hours = Math.floor(this.settings.auto_checklist_time / 100);
					let check_minutes = this.settings.auto_checklist_time % 100;
					let check_time = new Date(now.getFullYear(), now.getMonth(), now.getDate(), check_hours, check_minutes);
					check_time.setHours(check_hours);
					check_time.setMinutes(check_minutes);
					check_time.setSeconds(0);
					let is_today = now - check_time >= 0;
					// If checking for yesterday, substract a date
					if(!is_today) {
						check_time.setDate(now.getDate() - 1);
					}

					// Determine if the date should even be checked (via last_date_checked or habit_tracker)
					// Determine via last_date_checked
					if(this.persistent.last_date_checked.getDate() === check_time.getDate() 
						&& this.persistent.last_date_checked.getMonth() === check_time.getMonth()
						&& this.persistent.last_date_checked.getFullYear() === check_time.getFullYear()) {
						should_check = false;
					}
					else {
						// If checking yesterday, skip if today already has an entry
						if(!is_today) {
							let todays_entry = this.habit_tracker.get_date_entry(now);
							if(todays_entry !== null)
								should_check = false;
						}
						// If the date to check has all it's habits already accounted for, skip it
						if(should_check) {		
							let date_entry = this.habit_tracker.get_date_entry(check_time);
							if(date_entry) {
								let any_unset = false;
								for(let mask = 1; mask < (1<<this.habit_tracker.num_habits); mask<<=1) {
									if(!(date_entry & mask)) {
										any_unset = true;
										break;
									}
								}
								if(!any_unset)
									should_check = false;
							}
						}
					}

					// Set last_date_checked to check_time
					this.persistent.last_date_checked = check_time;

					// If still should check, open the popup
					if(should_check) {
						this.close_popup();
						this.habit_checklist_popup(true, !is_today);

						// Re-focus the date for calendar (if in current month)
						let new_focus_date = check_time.getMonth() === this.calendar.month ? check_time.getDate() : null;
						if(new_focus_date !== this.calendar.focus_date) {
							this.calendar.set_focus_date(new_focus_date);
						}
					}
				}
				// Else, set last_date_checked to current time, to prevent insta_popup when adding first habit
				else {
					this.persistent.last_date_checked = new Date(Date.now());
				}

				// If changed, save persistent_values so last_date_checked is consistent
				if(+old_last_date_checked !== +this.persistent.last_date_checked) {
					this.save_persistent_values();
				}
			}

			// TODAY_DATE_CHANGE
			start_today_date_change(interval_time=60000) {
				if(this.timers.today_date_change !== null)
					clearInterval(this.timers.today_date_change);
				this.today_date_change_handler();
				let timer = setInterval(this.today_date_change_handler.bind(this), interval_time);
				this.timers.today_date_change = timer;
				return timer;
			}
			stop_today_date_change() {
				if(this.timers.today_date_change !== null) {
					clearInterval(this.timers.today_date_change);
					this.today_date_change = null;
				}
			}
			today_date_change_handler() {
				let now = new Date(Date.now());
				let cur_year = now.getFullYear();
				let cur_month = now.getMonth();
				let cur_date = now.getDate();
				// Check if month or year has changed for calendar date, if so set month
				if(cur_month !== this.calendar.month || cur_year !== this.calendar.year) {
					this.calendar.set_month(cur_month, cur_year); // Has refresh in the function
				}
				// Else if date has changed, just change the date and refresh
				else if(cur_date !== this.calendar.date) {
					this.calendar.date = cur_date;
					this.generate_site();
					// If popup is not open, then set today as focus date
					if(!$('#popup').hasClass('popup-opened')) {
						this.calendar.set_focus_date(cur_date);
					}
				}
			}


			set_intervals() {
				this.start_today_date_change(60000);
				this.start_auto_checklist(60000);
			}
			stop_intervals() {
				this.stop_today_date_change();
				this.stop_auto_checklist();
			}

			/* TEMPORARY */
			set_test_habits() {
				this.habit_tracker.add_habit('Wake Up', '#bae1ff');
				this.habit_tracker.add_habit('Work', '#baffc9');
				this.habit_tracker.add_habit('Pee', '#ffffba');
				this.habit_tracker.add_tracked_habit(2019, 3, 21, 1);
				this.habit_tracker.add_tracked_habit(2019, 3, 21, 0);
			}

			/* POPUP COMMANDS
			----------------- */
			create_popup_with_scrim(extra_classes) {
				// Create popup-content
				let popup = document.createElement('div');
				popup.setAttribute('class', 'popup-content '+extra_classes);
				// Create scrim
				let scrim = document.createElement('div');
				scrim.setAttribute('class', 'popup-scrim');
				scrim.setAttribute('onclick', '$(document).trigger(\'calendar:close_popup\');');
				popup.appendChild(scrim);
				// Create close button
				let close_button = document.createElement('div');
				close_button.setAttribute('class', 'popup-close');
				close_button.setAttribute('onclick', '$(document).trigger(\'calendar:close_popup\');');
				close_button.innerText = 'X';
				popup.append(close_button);
				return popup;
			}

			open_popup() {
				$('#popup').addClass('popup-opened');
			}
			close_popup() {
				$('#popup .popup-content').remove();
				$('#popup').removeClass('popup-opened');
			}

			habit_checklist_popup(daily_popup=false, check_yesterday=false) {
				// If there are no habits, never pull up this popup
				if(this.habit_tracker.num_habits === 0) {
					return;
				}

				// If no focus_date, this is a compromised call, cancel out with a warning
				let calendar_date = this.calendar.date_obj;
				if(calendar_date === null) {
					console.warn('habit_checklist_popup: calendar_date is null, cannot determine which date to use!');
					return;
				}

				// Initialize popup_content div
				let popup_content = this.create_popup_with_scrim('checklist-popup');

				// If daily_popup, include greeting in the header
				if(daily_popup) {
					let greeting = document.createElement('div');
					greeting.setAttribute('class', 'checklist-greeting');
					greeting.innerText = `Let's check what you did ${check_yesterday ? 'yesterday' : 'today'}!`;
					popup_content.appendChild(greeting);
				}

				// Include date string
				let date_string = calendar_date.toLocaleString('en-us', {'weekday': 'long', 'year': 'numeric', 'month': 'long', 'day': 'numeric'});
				let date_header = document.createElement('div');
				date_header.setAttribute('class', 'popup-header checklist-date');
				date_header.innerText = date_string;
				popup_content.appendChild(date_header);

				// Include line
				let header_line = document.createElement('div');
				header_line.setAttribute('class', 'popup-header-line');
				popup_content.appendChild(header_line);

				// Include checklist
				let checklist_click_handler_generator = (function(habit_index) { // TEST IMPLEMENTATION
					return (function(e) {
						let target = e.currentTarget;
						let is_active = $(target).hasClass('entry-active');
						// If active, remove the tracked habit and then remove entry-active class
						if(is_active) {
							this.habit_tracker.remove_tracked_habit(calendar_date.getFullYear(), calendar_date.getMonth(), calendar_date.getDate(), habit_index, this.calendar);
							$(target).removeClass('entry-active');
							this.debounced_save();
						}
						// Else, add the tracked habit and add entry-active class
						else {
							this.habit_tracker.add_tracked_habit(calendar_date.getFullYear(), calendar_date.getMonth(), calendar_date.getDate(), habit_index, this.calendar);
							$(target).addClass('entry-active');
							this.debounced_save();
						}
					}).bind(this);
				}).bind(this);
				let checklist_container = document.createElement('div');
				checklist_container.setAttribute('class', 'checklist-container');
				let date_entry = this.habit_tracker.get_date_entry(calendar_date) || 0;
				for(let k=0; k<this.habit_tracker.num_habits; k+=1) {
					let habit = this.habit_tracker.habits[k];
					let habit_active = date_entry & (1<<k);

					// Container div
					let checklist_habit_entry = document.createElement('div');
					checklist_habit_entry.setAttribute('class', `checklist-habit-entry${habit_active ? ' entry-active' : ''}`);
					$(checklist_habit_entry).click(checklist_click_handler_generator(k));

					// Checkbox
					let checkbox = document.createElement('div');
					checkbox.setAttribute('class', 'checklist-checkbox');
					let checkbox_inner = document.createElement('div');
					checkbox_inner.setAttribute('class', 'checklist-checkbox-inner');
					checkbox_inner.setAttribute('style', `border-color: ${habit.color};`);
					let checkbox_inner_bg = document.createElement('div');
					checkbox_inner_bg.setAttribute('class', 'checklist-checkbox-inner-bg');
					checkbox_inner_bg.setAttribute('style', `background-color: ${habit.color};`);
					checkbox_inner.appendChild(checkbox_inner_bg);
					checkbox.appendChild(checkbox_inner);
					checklist_habit_entry.appendChild(checkbox);

					// Habit name
					let habit_name = document.createElement('span');
					habit_name.setAttribute('class', 'checklist-habit-name');
					habit_name.innerText = habit.name;
					checklist_habit_entry.appendChild(habit_name);

					// Append entry
					checklist_container.appendChild(checklist_habit_entry);
				}

				// Append checklist_container
				popup_content.appendChild(checklist_container);

				// Append popup_content
				$('#popup')[0].appendChild(popup_content);
				this.open_popup();
			}

			add_habit_popup() {
				// Initialize popup_content div
				let popup_content = this.create_popup_with_scrim('add-habit-popup');

				// Header
				let header = document.createElement('div');
				header.setAttribute('class', 'popup-header');
				header.innerText = 'Add New Habit';
				popup_content.appendChild(header);

				// Include line
				let header_line = document.createElement('div');
				header_line.setAttribute('class', 'popup-header-line');
				popup_content.appendChild(header_line);

				// Handler for figuring out if the submit button should be active
				let determine_submit_button_state = function() {
					let submit_button = $('.add-habit-popup .submit-button');
					let is_inactive = $(submit_button).hasClass('inactive-button');
					let should_be_active = true;
					let input = $('.add-habit-popup .habit-name-input')[0];
					if(input.value.length === 0 || $('.add-habit-popup .color-picker-option.selected').length === 0)
						should_be_active = false;
					// Adjust submit_button state
					if(should_be_active && is_inactive)
						$(submit_button).removeClass('inactive-button');
					else if(!should_be_active && !is_inactive)
						$(submit_button).addClass('inactive-button');
				}

				// Input box
				let name_input = document.createElement('input');
				name_input.setAttribute('class', 'habit-name-input');
				name_input.setAttribute('placeholder', 'Habit name');
				name_input.setAttribute('maxlength', 20);
				$(name_input).on('input', determine_submit_button_state);
				popup_content.appendChild(name_input);

				// Color picker selection handler generator
				let selection_handler = function(e) {
					let target = e.currentTarget;
					$('.add-habit-popup .color-picker-option.selected').removeClass('selected');
					$(target).addClass('selected');
					determine_submit_button_state(); // Update submit button state
				};
				// Color picker
				let color_picker_container = document.createElement('div');
				color_picker_container.setAttribute('class', 'color-picker-container');
				// Color picker rows
				for(let i=0; i<4; i+=1) {
					let color_picker_row = document.createElement('div');
					color_picker_row.setAttribute('class', 'color-picker-row');
					// Color picker option
					for(let j=0; j<4; j+=1) {
						let color_picker_option = document.createElement('div');
						color_picker_option.setAttribute('class', 'color-picker-option');
						let color_index = 4*i + j;
						if(color_index < habit_colors.length) {
							let option_color = habit_colors[color_index];
							color_picker_option.setAttribute('style', `background-color: ${option_color}`);
							color_picker_option.setAttribute('color-value', option_color);
							$(color_picker_option).click(selection_handler);
							// Determine if the color is available
							for(let k=0; k<this.habit_tracker.num_habits; k+=1) {
								let habit_color = this.habit_tracker.habits[k].color;
								if(habit_color === option_color) {
									$(color_picker_option).addClass('option-unavailable');
									break;
								}
							}
						}
						// Append option
						color_picker_row.appendChild(color_picker_option);
					}
					// Append row
					color_picker_container.appendChild(color_picker_row);
				}

				// Append color picker
				popup_content.appendChild(color_picker_container);

				// Submit button
				let submit_button = document.createElement('div');
				submit_button.setAttribute('class', 'submit-button inactive-button');
				submit_button.innerText = 'Add Habit';
				$(submit_button).click((function() {
					// If any of the values are bad, don't do anything
					let input = $('.add-habit-popup .habit-name-input')[0];
					let selected_colors = $('.add-habit-popup .color-picker-option.selected');
					if(input.value.length === 0 || selected_colors.length === 0)
						return;
					// Close popup
					this.close_popup();
					// Add habit
					let name = input.value;
					let color = $(selected_colors).attr('color-value');
					this.habit_tracker.add_habit(name, color);
					// Debounced save
					this.debounced_save();
					// Refresh calendar
					this.generate_site();
				}).bind(this));
				popup_content.appendChild(submit_button)

				// Append popup_content
				$('#popup')[0].appendChild(popup_content);
				this.open_popup();
			}

			edit_habit_popup(habit_index) {
				// Out of bounds check
				if(habit_index >= this.habit_tracker.num_habits) {
					console.warn(`edit_habit_popup: habit_index of ${habit_index} is out of bounds`);
					return;
				}

				let cur_habit = this.habit_tracker.habits[habit_index];

				// Initialize popup_content div
				let popup_content = this.create_popup_with_scrim('add-habit-popup');

				// Header
				let header = document.createElement('div');
				header.setAttribute('class', 'popup-header');
				header.innerText = 'Add New Habit';
				popup_content.appendChild(header);

				// Include line
				let header_line = document.createElement('div');
				header_line.setAttribute('class', 'popup-header-line');
				popup_content.appendChild(header_line);

				// Handler for figuring out if the submit button should be active
				let determine_submit_button_state = function() {
					let submit_button = $('.add-habit-popup .submit-button');
					let is_inactive = $(submit_button).hasClass('inactive-button');
					let input = $('.add-habit-popup .habit-name-input')[0];
					let should_be_active = input.value.length > 0;
					// Adjust submit_button state
					if(should_be_active && is_inactive)
						$(submit_button).removeClass('inactive-button');
					else if(!should_be_active && !is_inactive)
						$(submit_button).addClass('inactive-button');
				}

				// Input box
				let name_input = document.createElement('input');
				name_input.setAttribute('class', 'habit-name-input');
				name_input.setAttribute('placeholder', 'Habit name');
				name_input.setAttribute('maxlength', 20);
				name_input.value = cur_habit.name;
				$(name_input).on('input', determine_submit_button_state);
				popup_content.appendChild(name_input);

				// Color picker selection handler generator
				let selection_handler = function(e) {
					let target = e.currentTarget;
					$('.add-habit-popup .color-picker-option.selected').removeClass('selected');
					$(target).addClass('selected');
					//determine_submit_button_state(); // DON'T NEED THIS FOR THIS ONE
				};
				// Color picker
				let color_picker_container = document.createElement('div');
				color_picker_container.setAttribute('class', 'color-picker-container');
				// Color picker rows
				for(let i=0; i<4; i+=1) {
					let color_picker_row = document.createElement('div');
					color_picker_row.setAttribute('class', 'color-picker-row');
					// Color picker option
					for(let j=0; j<4; j+=1) {
						let color_picker_option = document.createElement('div');
						color_picker_option.setAttribute('class', 'color-picker-option');
						let color_index = 4*i + j;
						if(color_index < habit_colors.length) {
							let option_color = habit_colors[color_index];
							color_picker_option.setAttribute('style', `background-color: ${option_color}`);
							color_picker_option.setAttribute('color-value', option_color);
							$(color_picker_option).click(selection_handler);
							// Determine if the color is available
							for(let k=0; k<this.habit_tracker.num_habits; k+=1) {
								let habit_color = this.habit_tracker.habits[k].color;
								if(habit_color === option_color) {
									// If k is habit_index, then set it is selected instead
									if(k === habit_index)
										$(color_picker_option).addClass('selected');
									else
										$(color_picker_option).addClass('option-unavailable');
									break;
								}
							}
						}
						// Append option
						color_picker_row.appendChild(color_picker_option);
					}
					// Append row
					color_picker_container.appendChild(color_picker_row);
				}

				// Append color picker
				popup_content.appendChild(color_picker_container);

				// Submit button
				let submit_button = document.createElement('div');
				submit_button.setAttribute('class', 'submit-button');
				submit_button.innerText = 'Edit Habit';
				$(submit_button).click((function() {
					// If any of the values are bad, don't do anything
					let input = $('.add-habit-popup .habit-name-input')[0];
					let selected_colors = $('.add-habit-popup .color-picker-option.selected');
					if(input.value.length === 0 || selected_colors.length === 0)
						return;
					// Close popup
					this.close_popup();
					// Add habit
					let name = input.value;
					let color = $(selected_colors).attr('color-value');
					this.habit_tracker.habits[habit_index] = {
						'name': name,
						'color': color,
					};
					// Debounced save
					this.debounced_save();
					// Refresh calendar
					this.generate_site();
				}).bind(this));
				popup_content.appendChild(submit_button)

				// Remove button
				let remove_button = document.createElement('div');
				remove_button.setAttribute('class', 'remove-button');
				remove_button.innerText = 'Remove Habit';
				$(remove_button).click((function() {
					this.close_popup();
					// Remove habit
					this.habit_tracker.remove_habit(habit_index);
					// Debounced save
					this.debounced_save();
					// Refresh calendar
					this.generate_site();
				}).bind(this));
				popup_content.appendChild(remove_button);

				// Append popup_content
				$('#popup')[0].appendChild(popup_content);
				this.open_popup();
			}
		}

		var main = new Main(); // EXPOSED FOR TESTING
		$(document).ready(function() {
			// let main = new Main();

			main.load();
			main.close_popup();

			main.initiate_handlers();
			console.log('handlers initiated');
			main.set_intervals();
			console.log('intervals set');
			main.generate_site();
		});
	</script>
</body>
</html>