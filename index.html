<!DOCTYPE html>
<html>
<head>
	<!-- General Meta Tags -->
	<title>Habit Tracker</title>
	<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=no">
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="description" content="A calendar for tracking your habits in order to visually see your consistency and progress and encourage dedication.">

	<!-- Style -->
	<link rel="stylesheet" href="/static/style.css">

	<!-- Scripts -->
	<script src="/static/js/jquery.min.js"></script>
</head>
<body>

	<div id="calendarContainer">
		
	</div>


	<!-- Scripts -->
	<!-- Cookie Handling -->
	<script type="text/javascript">
		// Returns an object based on all the cookies
		function get_cookie_object() {
			let cookie_obj = {};
			let cookie_strings = document.cookie.split(';');
			let re = /\s*(.+)=(.*)/;
			for(let i=0; i<cookie_strings.length; i+=1) {
				let str = cookie_strings[i];
				let match = re.exec(str);
				if(match) {
					let key = match[1];
					let val = match[2];
					cookie_obj[key] = decodeURIComponent(val);
				}
				else {
					console.warn(`get_cookie_object: unable to parse cookie_string "${str}"`);
				}
			}
			return cookie_obj;
		}

		function save_cookie(key, value) {
			document.cookie = `${key}=${encodeURIComponent(value)}; expires=2147483647`;
			console.log(`${key}=${encodeURIComponent(value)}; expires=2147483647`);
		}
	</script>

	<!-- SVG Generator -->
	<script type="text/javascript">
		/* SVG ELEMENT GENERATORS
		========================= */
		function svg_elem(tag, attrs) {
			let elem = document.createElementNS('http://www.w3.org/2000/svg', tag);
			Object.entries(attrs).forEach(entry => {
				let key = entry[0];
				let val = entry[1];
				if(val !== null && val !== undefined)
					elem.setAttributeNS(null, key, val);
			});
			return elem;
		}

		function svg_svg(id, width, height, other_attrs) {
			let attrs = {
				'id': id,
				'width': width,
				'height': height,
			};
			if(other_attrs)
				Object.assign(attrs, other_attrs);
			return svg_elem('svg', attrs);
		}

		function svg_g(id, other_attrs) {
			let attrs = {
				'id': id,
			};
			if(other_attrs)
				Object.assign(attrs, other_attrs);
			return svg_elem('g', attrs);
		}


		/* CONTEXT BASED SVG-GENERATOR UTILITY
		====================================== */
		class SvgGenerator {
			/* CONSTRUCTOR
			-------------- */
			constructor(id, width, height) {
				this._svg = svg_svg(id, width, height);
				this._context = {
					'elem': this._svg,
					'x': 0,
					'y': 0,
				};
				this._context_stack = [this._context];
			}

			/* GETTERS
			---------- */
			get svg() {
				return this._svg;
			}
			get context() {
				return this._context;
			}
			get context_elem() {
				if(!this._context)
					return null;
				return this._context.elem;
			}
			get context_x() {
				if(!this._context)
					return null;
				return this._context.x;
			}
			get context_y() {
				if(!this._context)
					return null;
				return this._context.y;
			}
			get context_id() {
				if(!this._context)
					return null;
				return this._context.elem.getAttribute('id');
			}

			/* QUERIES
			---------- */
			at_base_layer() {
				return this._context_stack.length === 1;
			}

			/* CONTEXT MANIPULATION
			----------------------- */
			new_layer(id, x=0, y=0, other_attrs) {
				let g = svg_g(id, other_attrs);
				let new_context = {
					'elem': g,
					'x': x + this._context.x,
					'y': y + this._context.y,
				}
				this._context = new_context;
				this._context_stack.push(new_context);
				return g;
			}

			end_layer() {
				if(this.at_base_layer())
					return false;
				let popped_elem = this._context_stack.pop().elem;
				this._context = this._context_stack[this._context_stack.length - 1];
				// Append the finished layer to the parent layer
				this._context.elem.appendChild(popped_elem);
				return true;
			}

			flush() {
				while(this.end_layer());
			}

			/* GENERATION FUNCTIONS
			----------------------- */
			add_elem(tag, attrs) {
				let elem = svg_elem(tag, attrs);
				this._context.elem.appendChild(elem);
				return elem;
			}

			add_circle(id, x, y, r, other_attrs) {
				let attrs = {
					'id': id,
					'cx': x + this._context.x,
					'cy': y + this._context.y,
					'r': r,
				};
				if(other_attrs)
					Object.assign(attrs, other_attrs);
				return this.add_elem('circle', attrs);
			}

			add_rect(id, x, y, width, height, other_attrs) {
				let attrs = {
					'id': id,
					'x': x + this._context.x,
					'y': y + this._context.y,
					'width': width,
					'height': height,
				};
				if(other_attrs)
					Object.assign(attrs, other_attrs);
				return this.add_elem('rect', attrs);
			}

			add_line(id, x1, y1, x2, y2, other_attrs) {
				let attrs = {
					'id': id,
					'x1': x1 + this._context.x,
					'y1': y1 + this._context.y,
					'x2': x2 + this._context.x,
					'y2': y2 + this._context.y,
				};
				if(other_attrs)
					Object.assign(attrs, other_attrs);
				return this.add_elem('line', attrs);
			}

			add_slice(id, cx, cy, r, start_angle, theta, other_attrs) {
				// Full_circle case
				if(theta >= 2*Math.PI) {
					return this.add_circle(id, cx, cy, r, other_attrs);
				}

				// Slice case (using arc)
				cx += this._context.x;
				cy += this._context.y;
				// Get the start and end points for the arc
				let x1 = cx + r*Math.sin(start_angle);
				let y1 = cy - r*Math.cos(start_angle);
				let x2 = cx + r*Math.sin(start_angle + theta);
				let y2 = cy - r*Math.cos(start_angle + theta);

				let large_arc = theta > Math.PI ? 1 : 0; // Determines whether to take the larger arc, only 1 when theta > 180
				let sweep = 1; // Determines the direction around the circle to travel, always 1

				// Create path for slice
				let slice_path = `M ${cx} ${cy} L ${x1} ${y1} A ${r} ${r} 0 ${large_arc} ${sweep} ${x2} ${y2} Z`;
				// Consctruct element
				let attrs = {
					'id': id, 
					'd': slice_path,
				}
				if(other_attrs)
					Object.assign(attrs, other_attrs);
				return this.add_elem('path', attrs);
			}

			add_text(id, x, y, text, other_attrs) {
				let attrs = {
					'id': id,
					'x': x + this._context.x,
					'y': y + this._context.y,
				}
				if(other_attrs)
					Object.assign(attrs, other_attrs);
				let elem = svg_elem('text', attrs);
				elem.textContent = text;
				this._context.elem.appendChild(elem);
				return elem;
			}

			add_use(id, href) {
				let attrs = {
					'id': id,
				}
				let elem = this.add_elem('use', attrs);
				elem.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', `#${href}`);
				return elem;
			}
		}
	</script>

	<!-- Habit Tracker / Database -->
	<script type="text/javascript">
		/* CONSTANTS
		------------ */
		let max_habits = 16;
		let max_years = 10;

		class HabitTracker {
			/* CONSTRUCTOR
			-------------- */
			constructor() {
				// Can hold 16 habit objects, which contain a `name` entry and a `color` entry
				this.habits = [];
				// Tracker contains entry for each year with a tracked date, and within that a year object
				// Year object contains entry for each day with a tracked habit in the form 'mm-dd'
				// Each tracked day has a 16-bit bit-map of indexed habits (serialized as 4-digit hex)
				// Will look like `mm-dd:00;` (THERE MAY BE AN ISSUE WITH NULL CHAR WITH THIS, MUST LOOK UP)
				this.tracker = {}; 
			}

			/* GETTERS
			---------- */
			get num_habits() {
				return this.habits.length;
			}

			static get_date_key(month, date) {
				return `${month < 10 ? '0'+month : month}-${date < 10 ? '0'+date : date}`;
			} 

			/* Modifiers
			------------ */
			add_habit(name, color) {
				if(this.habits.length >= max_habits) {
					console.warn(`CANNOT ADD HABIT: reached maximum of ${max_habits}`);
					return false;
				}
				this.habits.push({'name': name, 'color': color});
				return true;
			}
			remove_habit(index) {
				if(index >= this.habits.length) {
					console.warn(`CANNOT REMOVE HABIT: index:${index} is out of bounds`);
					return false;
				}
				this.habits.splice(index, 1);
				// Adjust ALL tracked habits to match bit-flag reperesentation
				let shift_mask = ~0 << (index+1);
				let nonshift_mask = ~shift_mask >> 1;
				for(let year_id in this.tracker) {
					let year_entry = this.tracker[year_id];
					for(let date_id in year_entry) {
						let date_entry = year_entry[date_id];
						date_entry = ((date_entry&shift_mask) >> 1) | (date_entry&nonshift_mask);
						year_entry[date_id] = date_entry;
					}
				}
				return true;
			}

			add_tracked_habit(year, month, date, habit_index) {
				if(habit_index >= this.habits.length) {
					console.warn(`CANNOT TRACK HABIT: index:${habit_index} is out of bounds`);
					return false;
				}
				// If year entry doesn't exist, create it
				let year_entry = this.tracker[year];
				if(year_entry === undefined) {
					year_entry = {};
					this.tracker[year] = year_entry;
				}
				// Get date key for date entry
				let date_key = HabitTracker.get_date_key(month, date);
				// If habit is already tracked, return false
				if(year_entry[date_key] & (1<<habit_index))
					return false;
				// Add the tracked habit to the bit-map (undefined acts like 0)
				year_entry[date_key] |= (1<<habit_index);
				return true;
			}

			remove_tracked_habit(year, month, date, habit_index) {
				// If year entry doesn't exist, return false
				let year_entry = this.tracker[year];
				if(year_entry === undefined)
					return false;
				// Get date key for date entry
				let date_key = HabitTracker.get_date_key(month, date);
				// If habit is not tracked, return false
				if(!(year_entry[date_key] & (1<<habit_index)))
					return false;
				// Remove the tracked habit form the bit-map
				year_entry[date_key] &= ~(1<<habit_index);
				return true;
			}

			/* Serialization / Deserialization
			---------------------------------- */
			// Serialize directly to JSON
			serialize_habits() {
				return JSON.stringify(this.habits);
			}
			// Deserialize directly from JSON
			deserialize_habits(cookie_obj, use_alt) {
				// Set get proper habits_string appropriate to use_alt
				let habits_string = use_alt ? cookie_obj['~habits'] : cookie_obj['habits'];
				try {
					let deserialized_habits = JSON.parse(habits_string);
					return deserialized_habits;
				}
				catch(err) {
					return null;
				}
			}

			// Return a object with year_ids mapped to serialized year_entries instead of 
			serialize_tracker() {
				// Trim years to only allow the latest `max_years` amount to be serialized
				let year_keys = Object.keys(this.tracker).sort().reverse().slice(0,max_years);
				// Serialize the years
				let serialized_tracker = {};
				for(let i=0; i<year_keys.length; i+=1) {
					let year_key = year_keys[i];
					let serialized_year_key = `y${year_key}`;
					serialized_tracker[serialized_year_key] = this.serialize_year_entry(this.tracker[year_key]);
				}
				return serialized_tracker;
			}
			serialize_year_entry(year_entry) {
				let serialized = [];
				for(let date_key in year_entry) {
					let serialized_date = this.serialize_date_entry(date_key, year_entry[date_key]);
					serialized.push(serialized_date);
				}
				return serialized.join('');
			}
			serialize_date_entry(date_key, date_entry) {
				return `${date_key}:${date_entry.toString(16)},`;
			}

			// Deserialize tracker
			deserialize_tracker(cookie_obj, use_alt) {
				let deserialized_tracker = {};
				// Set the regex for key information
				let re = use_alt ? /~y(\d{4})/ : /y(\d{4})/;
				for(let key in cookie_obj) {
					let match = re.exec(key);
					if(match) {
						let year_id = match[1];
						let serialized_entry = cookie_obj[key];
						deserialized_tracker[year_id] = this.deserialize_year_entry(serialized_entry);
					}
				}
				return deserialized_tracker;
			}
			deserialize_year_entry(serialized) {
				let year_entry = {};
				let re = /(\d\d-\d\d):([abcdef\d]{1,4}),/g;
				let match;
				while(match = re.exec(serialized)) {
					let date_key = match[1];
					let date_entry = parseInt(match[2], 16);
					year_entry[date_key] = date_entry;
				}
				return year_entry;
			}

			/* Saving and Loading Cookies
			----------------------------- */
			save_to_cookies() {
				// Get object with current cookies
				let cookie_obj = get_cookie_object();
				// Serialize habits and tracker
				let serialized_habits = this.serialize_habits();
				let serialized_tracker = this.serialize_tracker();
				// If use_alt exists and is set to 0, make alt keys: prefix cookie keys with "~"
				let use_alt_cookie = cookie_obj['use_alt'];
				let use_alt = use_alt_cookie === '0';
				// Save habits
				save_cookie(use_alt ? '~habits' : 'habits', serialized_habits);
				// Save tracker year_entries
				for(let key in serialized_tracker) {
					save_cookie(use_alt ? `~${key}` : key, serialized_tracker[key]);
				}
				// Toggle the `use_alt` tracker
				save_cookie('use_alt', use_alt ? 1 : 0);
			}

			load_from_cookies() {
				// Get object with current cookies
				let cookie_obj = get_cookie_object();
				// If use_alt is set to 1, cookie keys prefixed with "_"
				let use_alt_cookie = cookie_obj['use_alt'];
				let use_alt = use_alt_cookie === '1';
				// Load habits
				let deserialized_habits = this.deserialize_habits(cookie_obj, use_alt);
				// If habits fails to deserialize, don't even attempt to load tracker, return false as failure
				if(deserialized_habits != null)
					this.habits = deserialized_habits;
				else
					return false;
				// Load tracker
				this.tracker = this.deserialize_tracker(cookie_obj, use_alt);
				return true;
			}
		}
	</script>

	<!-- Calendar Layout -->
	<script type="text/javascript">
		class Calendar {
			/* CONSTRUCTOR
			-------------- */
			constructor(habit_tracker) {
				this.habit_tracker = habit_tracker;
				let now = new Date(Date.now());
				this.date = now.getDate();
				this.month = now.getMonth();
				this.year = now.getFullYear();
			}

			/* VIEW CHANGES
			--------------- */
			shift_month_forward() {
				if(this.month == 11) {
					this.month = 0;
					this.year += 1;
				}
				else {
					this.month += 1;
				}
				// If returning to current month, set date to today, otherwise set to null
				let now = new Date(Date.now());
				if(now.getMonth() == this.month)
					this.date = now.getDate();
				else
					this.date = null;
				// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				// REFRESH CALENDAR VIEW
			}
			shift_month_backward() {
				if(this.month == 0) {
					this.month = 11;
					this.year -= 1;
				}
				else {
					this.month -= 1;
				}
				// If returning to current month, set date to today, otherwise set to null
				let now = new Date(Date.now());
				if(now.getMonth() == this.month)
					this.date = now.getDate();
				else
					this.date = null;
				// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				// REFRESH CALENDAR VIEW
			}

			/* RENDERING
			------------ */
			generate_calendar(gen) {
				// CONSTANTS
				let date_radius = 40;
				let date_padding = 16;
				let focus_radius = 45;

				let alpha = 0.8;
				let stroke_and_text = '#888';
				// ---------

				// Get day of the week for first of the month
				let first_day = new Date(this.year, this.month, 1).getDay();
				// Get number of days (day=0 makes it show the last day of the current month, sinche month+1)
				let num_days = new Date(this.year, this.month+1, 0).getDate();
				// Get number of rows of dates
				let num_rows = 1 + Math.ceil((num_days - (7 - first_day))/7);
				// Get the year_entry from habit_tracker
				let year_entry = this.habit_tracker.tracker[this.year];

				// Start generating
				gen.new_layer(null, 0, 0, {'style': `opacity: ${alpha};`});
				let cur_date = 1;
				for(let i = 0; i<num_rows; i += 1) {
					let row_center = date_radius + 2*i*(date_radius + date_padding);
					gen.new_layer(`row${i}`, 0, row_center, {'fill':'transparent'});
					let j = i === 0 ? first_day : 0;
					while(j<7 && cur_date <= num_days) {
						let xc = date_radius + 2*j*(date_radius + date_padding);
						gen.new_layer(`day${cur_date}`, xc, 0, {'class':'date-circle'});

							// Determine slices to show from habit tracker
							if(year_entry && this.habit_tracker.num_habits) {
								let date_key = `${this.month < 10 ? '0'+this.month : this.month}-${cur_date < 10 ? '0'+cur_date : cur_date}`;
								let date_entry = year_entry[date_key];
								let slice_theta = 2*Math.PI/this.habit_tracker.num_habits;
								for(let k=0; k<this.habit_tracker.num_habits; k+=1) {
									if(date_entry & (1<<k)) {
										let habit_color = this.habit_tracker.habits[k].color;
										gen.add_slice(null, 0, 0, date_radius-0.5, k*slice_theta, slice_theta, 
											{'fill': habit_color});
									}
								}
							}

							// If is focused date, add an extra embelishing circle
							if(cur_date === this.date) {
								gen.add_circle(null, 0, 0, focus_radius, 
									{'stroke': stroke_and_text, 'stroke-width': 1});
							} 
							// Draw circle and text
							gen.add_circle(null, 0, 0, date_radius, 
								{'stroke': stroke_and_text, 'stroke-width': 1});
							gen.add_text(null, 0, 0, cur_date, {'fill': stroke_and_text, 'text-anchor': 'middle', 'alignment-baseline': 'central'})
						gen.end_layer();

						j += 1;
						cur_date += 1;
					}
					gen.end_layer();
				}
				gen.end_layer();
			}

			generate_habit_viewer(gen) {
				// CONSTANTS
				let viewer_radius = 80;
				let habit_text_x = -130;
				let habit_text_y = -80;
				let habit_text_x_padding = 6;
				let habit_text_length = 140;
				let habit_text_underline_padding = 10;
				let habit_focus_circle_radius = 4;
				let habit_focus_circle_radius_coeff = 0.65;

				let alpha = 0.8;
				let stroke_and_text = '#888';
				// ---------

				gen.new_layer(null, viewer_radius, 0, {'style': `opacity: ${alpha}; pointer-events: none;`});
				// Generate slices and habit text and line
				if(this.habit_tracker.num_habits) {
					let slice_theta = 2*Math.PI/this.habit_tracker.num_habits;
					for(let k=0; k<this.habit_tracker.num_habits; k+=1) {
						let habit = this.habit_tracker.habits[k]
						// New layer for slice
						gen.new_layer('habitViewerHabit', 0, 0);
						// Generate slice
						gen.add_slice('habitSlice', 0, 0, viewer_radius-0.5, k*slice_theta, slice_theta, 
							{'fill': habit.color});
						// Generate text
						gen.new_layer(`habitText${k}`, 0, 0, {'class': 'habit-text'});
						gen.add_text(null, habit_text_x, habit_text_y, habit.name, 
							{'text-anchor': 'end', 'fill': stroke_and_text});
						// Generate line under text
						let slice_point_angle = (k*slice_theta) + (slice_theta/2);
						let slice_point_x = 0;
						let slice_point_y = 0;
						// If not full circle, calculate real slice point
						if(this.habit_tracker.num_habits > 1) {
							slice_point_x = habit_focus_circle_radius_coeff*viewer_radius*Math.sin(slice_point_angle);
							slice_point_y = -habit_focus_circle_radius_coeff*viewer_radius*Math.cos(slice_point_angle);
						}
						let line_attrs = {
							'd': `M ${habit_text_x + habit_text_x_padding + gen._context.x - habit_text_length} ${habit_text_y + gen._context.y + habit_text_underline_padding} l ${habit_text_length} 0 L ${slice_point_x + gen._context.x} ${slice_point_y + gen._context.y}`,
							'stroke': stroke_and_text,
							'fill': 'transparent',
						};
						gen.add_elem('path', line_attrs);
						gen.end_layer();
						// Generate small circle for end of line
						gen.add_circle(null, slice_point_x, slice_point_y, habit_focus_circle_radius, 
							{'fill': habit.color, 'stroke': stroke_and_text, 'stroke-width': 1});

						// End layer
						gen.end_layer();
					}
				}

				// Draw circle
				gen.add_circle(null, 0, 0, viewer_radius, 
					{'fill': 'transparent', 'stroke': stroke_and_text, 'stroke-width': 1});

				// Generate use tags for habitText
				for(let k=0; k<this.habit_tracker.num_habits-1; k+=1) {
					gen.add_use(null, `habitText${k}`);
				}

				gen.end_layer();
			}

			generate_habit_list(gen) {
				// CONSTANTS
				let list_width = 240;
				let header_height = 10;
				let header_underline_padding = 8;

				let entry_height = 24;
				let half_entry_height = entry_height/2;
				let entry_margin = 6;
				let entry_padding = 6;
				let entry_border_radius = 4;

				let alpha = 0.8;
				let stroke_and_text = '#888';
				let light_stroke = '#ddd';
				// ---------

				// Main group layer
				gen.new_layer(null, 0, 0, {'style': `opacity: ${alpha};`});

				// Header
				gen.add_text('habitListHeader', 0, header_height, 'Habits', 
					{'fill': stroke_and_text, 'alignment-baseline': 'bottom'});
				gen.add_line(null, 0, header_height + header_underline_padding, list_width, header_height + header_underline_padding, 
					{'stroke': stroke_and_text, 'stroke-width': 1});

				// List layer
				gen.new_layer('habitList', 0, header_height + header_underline_padding + entry_margin);
				let current_y = 0;

				// Add habit button 
				if(this.habit_tracker.num_habits < max_habits) {
					// New layer
					gen.new_layer(null, 0, 0);
					// Add habit text
					gen.add_text(null, entry_padding, half_entry_height, '+ Add Habit', 
						{'fill': stroke_and_text, 'alignment-baseline': 'central'});
					// Button rect
					gen.add_rect(null, 0, 0, list_width, entry_height, 
						{'class': 'stroke-hover', 'fill': 'transparent', 'stroke': stroke_and_text, 'rx': entry_border_radius, 'ry': entry_border_radius, 'style': 'cursor: pointer;'});
					// End layer
					gen.end_layer();

					// Increment current_y
					current_y += entry_height + entry_margin;
				}

				// Habits
				for(let k=0; k<this.habit_tracker.num_habits; k+=1) {
					let habit = this.habit_tracker.habits[k];
					// New layer
					gen.new_layer(null, 0, current_y);
					// Underline
					gen.add_line(null, entry_border_radius, entry_height, list_width, entry_height, 
						{'stroke': light_stroke});
					// Color rect
					gen.add_rect(null, 0, 0, entry_height, entry_height, 
						{'fill': habit.color, 'stroke': stroke_and_text, 'rx': entry_border_radius, 'ry': entry_border_radius,});
					// Habit name
					gen.add_text(null, entry_height + entry_padding, half_entry_height, habit.name,
						{'fill': stroke_and_text, 'alignment-baseline': 'central'});
					// End layer
					gen.end_layer();

					// Increment current_y
					current_y += entry_height + entry_margin;
				}
			}
		}
	</script>

	<!-- Main -->
	<script type="text/javascript">
		$(document).ready(function() {
			let time_start = Date.now();

			let gen = new SvgGenerator('calendar', 1200, 800);

			let habit_tracker = new HabitTracker();
			let calendar = new Calendar(habit_tracker);

			habit_tracker.add_habit('Brushing', '#bae1ff');
			habit_tracker.add_habit('Work', '#ffffba');
			habit_tracker.add_habit('Pee', '#baffc9');
			habit_tracker.add_tracked_habit(2019, 3, 21, 1);
			habit_tracker.add_tracked_habit(2019, 3, 21, 0);

			// habit_tracker.load_from_cookies();
			// habit_tracker.save_to_cookies();

			gen.new_layer(null, 10, 140);
				calendar.generate_calendar(gen);
				gen.end_layer();
			gen.new_layer(null, 800, 140);
				calendar.generate_habit_viewer(gen);
				gen.new_layer(null, 0, 100);
					calendar.generate_habit_list(gen);
			gen.flush();

			let container = $('#calendarContainer');
			container.append(gen.svg);

			let time_end = Date.now();
			let time_to_process = (time_end - time_start)/1000;
			console.log(`Calendar rendered in: ${time_to_process}s`);
		});
	</script>
</body>
</html>