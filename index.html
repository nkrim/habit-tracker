<!DOCTYPE html>
<html>
<head>
	<!-- General Meta Tags -->
	<title>Habit Tracker</title>
	<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=no">
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="description" content="A calendar for tracking your habits in order to visually see your consistency and progress and encourage dedication.">

	<!-- Style -->
	<link rel="stylesheet" href="/static/style.css">

	<!-- Scripts -->
	<script src="/static/js/jquery.min.js"></script>
</head>
<body>

	<div id="calendarContainer">
		
	</div>


	<!-- Scripts -->
	<!-- SVG Generator -->
	<script type="text/javascript">
		/* SVG ELEMENT GENERATORS
		========================= */
		function svg_elem(tag, attrs) {
			let elem = document.createElementNS('http://www.w3.org/2000/svg', tag);
			Object.entries(attrs).forEach(entry => {
				let key = entry[0];
				let val = entry[1];
				if(val !== null && val !== undefined)
					elem.setAttributeNS(null, key, val);
			});
			return elem;
		}

		function svg_svg(id, width, height, other_attrs) {
			let attrs = {
				'id': id,
				'width': width,
				'height': height,
			};
			if(other_attrs)
				Object.assign(attrs, other_attrs);
			return svg_elem('svg', attrs);
		}

		function svg_g(id, other_attrs) {
			let attrs = {
				'id': id,
			};
			if(other_attrs)
				Object.assign(attrs, other_attrs);
			return svg_elem('g', attrs);
		}


		/* CONTEXT BASED SVG-GENERATOR UTILITY
		====================================== */
		class SvgGenerator {
			/* CONSTRUCTOR
			-------------- */
			constructor(id, width, height) {
				this._svg = svg_svg(id, width, height);
				this._context = {
					'elem': this._svg,
					'x': 0,
					'y': 0,
				};
				this._context_stack = [this._context];
			}

			/* GETTERS
			---------- */
			get svg() {
				return this._svg;
			}
			get context() {
				return this._context;
			}
			get context_elem() {
				if(!this._context)
					return null;
				return this._context.elem;
			}
			get context_x() {
				if(!this._context)
					return null;
				return this._context.x;
			}
			get context_y() {
				if(!this._context)
					return null;
				return this._context.y;
			}
			get context_id() {
				if(!this._context)
					return null;
				return this._context.elem.getAttribute('id');
			}

			/* QUERIES
			---------- */
			at_base_layer() {
				return this._context_stack.length === 1;
			}

			/* CONTEXT MANIPULATION
			----------------------- */
			new_layer(id, x=0, y=0, other_attrs) {
				let g = svg_g(id, other_attrs);
				let new_context = {
					'elem': g,
					'x': x + this._context.x,
					'y': y + this._context.y,
				}
				this._context = new_context;
				this._context_stack.push(new_context);
				return g;
			}

			end_layer() {
				if(this.at_base_layer())
					return false;
				let popped_elem = this._context_stack.pop().elem;
				this._context = this._context_stack[this._context_stack.length - 1];
				// Append the finished layer to the parent layer
				this._context.elem.appendChild(popped_elem);
				return true;
			}

			flush() {
				while(this.end_layer());
			}

			/* GENERATION FUNCTIONS
			----------------------- */
			add_elem(tag, attrs) {
				let elem = svg_elem(tag, attrs);
				this._context.elem.appendChild(elem);
				return elem;
			}

			add_circle(id, x, y, r, other_attrs) {
				let attrs = {
					'id': id,
					'cx': x + this._context.x,
					'cy': y + this._context.y,
					'r': r,
				};
				if(other_attrs)
					Object.assign(attrs, other_attrs);
				return this.add_elem('circle', attrs);
			}

			add_line(id, x1, y1, x2, y2, other_attrs) {
				let attrs = {
					'id': id,
					'x1': x1 + this._context.x,
					'y1': y1 + this._context.y,
					'x2': x2 + this._context.x,
					'y2': y2 + this._context.y,
				};
				if(other_attrs)
					Object.assign(attrs, other_attrs);
				return this.add_elem('line', attrs);
			}

			add_slice(id, cx, cy, r, start_angle, theta, other_attrs) {
				// Adjust points for context
				cx += this._context.x;
				cy += this._context.y;
				// Get the start and end points for the arc
				let x1 = cx + r*Math.sin(start_angle);
				let y1 = cy - r*Math.cos(start_angle);
				let x4 = cx + r*Math.sin(start_angle + theta);
				let y4 = cy - r*Math.cos(start_angle + theta);

				// Compute control points for bezier (math by @k88lawrence from https://stackoverflow.com/questions/734076/how-to-best-approximate-a-geometrical-arc-with-a-bezier-curve)
				let ax = x1 - cx;
				let ay = y1 - cy;
				let bx = x4 - cx;
				let by = y4 - cy;
				let q1 = ax * ax + ay * ay;
				let q2 = q1 + ax * bx + ay * by;
				let k2 = (4/3) * (Math.sqrt(2 * q1 * q2) - q2) / (ax * by - ay * bx);

				let x2 = cx + ax - k2 * ay;
				let y2 = cy + ay + k2 * ax;
				let x3 = cx + bx + k2 * by;
				let y3 = cy + by - k2 * bx;

				// Create path for slice
				let slice_path = `M ${cx} ${cy} L ${x1} ${y1} C ${x2} ${y2}, ${x3} ${y3}, ${x4} ${y4} Z`;
				// Consctruct element
				let attrs = {
					'id': id, 
					'd': slice_path,
				}
				if(other_attrs)
					Object.assign(attrs, other_attrs);
				return this.add_elem('path', attrs);
			}

			add_text(id, x, y, text, other_attrs) {
				let attrs = {
					'id': id,
					'x': x + this._context.x,
					'y': y + this._context.y,
				}
				if(other_attrs)
					Object.assign(attrs, other_attrs);
				let elem = svg_elem('text', attrs);
				elem.textContent = text;
				this._context.elem.appendChild(elem);
				return elem;
			}
		}
	</script>

	<!-- Habit Tracker / Database -->
	<script type="text/javascript">
		/* CONSTANTS
		------------ */
		let max_habits = 16;

		class HabitTracker {
			/* CONSTRUCTOR
			-------------- */
			constructor() {
				// Can hold 16 habit objects, which contain a `name` entry and a `color` entry
				this.habits = [];
				// Tracker contains entry for each year with a tracked date, and within that a year object
				// Year object contains entry for each day with a tracked habit in the form 'mm-dd'
				// Each tracked day has a 16-bit bit-map of indexed habits (serialized into 2 characters)
				this.tracker = {}; 
			}

			/* GETTERS
			---------- */
			get num_habits() {
				return this.habits.length;
			}

			/* Modifiers
			------------ */
			add_habit(name, color) {
				if(this.habits.length >= max_habits) {
					console.warn(`CANNOT ADD HABIT: reached maximum of ${max_habits}`);
					return false;
				}
				this.habits.push({'name': name, 'color': color});
				return true;
			}
			remove_habit(index) {
				if(index >= this.habits.length) {
					console.warn(`CANNOT REMOVE HABIT: index:${index} is out of bounds`);
					return false;
				}
				this.habits.splice(index, 1);
				// Adjust ALL tracked habits to match bit-flag reperesentation
				var shift_mask = ~0 << (index+1);
				var nonshift_mask = ~shift_mask >> 1;
				for(var year_id in this.tracker) { // !!!!! FIX THIS WHEN YOU HAVE INTERNET, ITERATE OVER VALUES
					var year_entry = this.tracker[year_id];
					for(var date_id in year_entry) {
						var date_entry = year_entry[date_id];
						date_entry = ((date_entry&shift_mask) >> 1) | (date_entry&nonshift_mask);
						year_entry[date_id] = date_entry;
					}
				}
				return true;
			}

			add_tracked_habit(year, month, date, habit_index) {
				if(habit_index >= this.habits.length) {
					console.warn(`CANNOT TRACK HABIT: index:${habit_index} is out of bounds`);
					return false;
				}
				// If year entry doesn't exist, create it
				let year_entry = this.tracker[year];
				if(year_entry === undefined) {
					year_entry = {};
					this.tracker[year] = year_entry;
				}
				// Get date key for date entry
				let date_key = `${month < 10 ? '0'+month : month}-${date < 10 ? '0'+date : date}`;
				// If habit is already tracked, return false
				if(year_entry[date_key] & (1<<habit_index))
					return false;
				// Add the tracked habit to the bit-map (undefined acts like 0)
				year_entry[date_key] |= (1<<habit_index);
				return true;
			}

			remove_tracked_habit(year, month, date, habit_index) {
				// If year entry doesn't exist, return false
				let year_entry = this.tracker[year];
				if(year_entry === undefined)
					return false;
				// Get date key for date entry
				let date_key = `${month < 10 ? '0'+month : month}-${date < 10 ? '0'+date : date}`;
				// If habit is not tracked, return false
				if(!(year_entry[date_key] & (1<<habit_index)))
					return false;
				// Remove the tracked habit form the bit-map
				year_entry[date_key] &= ~(1<<habit_index);
				return true;
			}

			/* Serialization / Decoding
			--------------------------- */
			serialize_habits() {

			}

			serialize_tracker() {

			}

		}
	</script>

	<!-- Calendar Layout -->
	<script type="text/javascript">
		class Calendar {
			/* CONSTRUCTOR
			-------------- */
			constructor(habit_tracker) {
				this.habit_tracker = habit_tracker;
				let now = new Date(Date.now());
				this.date = now.getDate();
				this.month = now.getMonth();
				this.year = now.getFullYear();
			}

			/* VIEW CHANGES
			--------------- */
			shift_month_forward() {
				if(this.month == 11) {
					this.month = 0;
					this.year += 1;
				}
				else {
					this.month += 1;
				}
				// If returning to current month, set date to today, otherwise set to null
				let now = new Date(Date.now());
				if(now.getMonth() == this.month)
					this.date = now.getDate();
				else
					this.date = null;
				// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				// REFRESH CALENDAR VIEW
			}
			shift_month_backward() {
				if(this.month == 0) {
					this.month = 11;
					this.year -= 1;
				}
				else {
					this.month -= 1;
				}
				// If returning to current month, set date to today, otherwise set to null
				let now = new Date(Date.now());
				if(now.getMonth() == this.month)
					this.date = now.getDate();
				else
					this.date = null;
				// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				// REFRESH CALENDAR VIEW
			}

			/* RENDERING
			------------ */
			generate_calendar(gen) {
				// CONSTANTS
				let date_radius = 40;
				let date_padding = 16;
				// ---------

				// Get day of the week for first of the month
				let first_day = new Date(this.year, this.month, 1).getDay();
				// Get number of days (day=0 makes it show the last day of the current month, sinche month+1)
				let num_days = new Date(this.year, this.month+1, 0).getDate();
				// Get number of rows of dates
				let num_rows = 1 + Math.ceil((num_days - (7 - first_day))/7);
				// Get the year_entry from habit_tracker
				let year_entry = this.habit_tracker.tracker[this.year];

				// Start generating
				var cur_date = 1;
				for(var i = 0; i<num_rows; i += 1) {
					let row_center = date_radius + 2*i*(date_radius + date_padding);
					gen.new_layer(`row${i}`, 0, row_center, {'fill':'transparent'});
					var j = i === 0 ? first_day : 0;
					while(j<7 && cur_date <= num_days) {
						let xc = date_radius + 2*j*(date_radius + date_padding);
						gen.new_layer(`day${cur_date}`, xc, 0);

							// Determine slices to show from habit tracker
							if(year_entry && this.habit_tracker.num_habits) {
								let date_key = `${this.month < 10 ? '0'+this.month : this.month}-${cur_date < 10 ? '0'+cur_date : cur_date}`;
								let date_entry = year_entry[date_key];
								let slice_theta = 2*Math.PI/this.habit_tracker.num_habits;
								// Full circle case
								if(this.habit_tracker.num_habits === 1) {
									if(date_entry) {
										let habit_color = this.habit_tracker.habits[0].color;
										gen.add_circle(null, 0, 0, date_radius-0.5, {'fill': habit_color});
									}
								}
								// Slice case
								else {
									for(var k=0; k<this.habit_tracker.num_habits; k+=1) {
										if(date_entry & (1<<k)) {
											let habit_color = this.habit_tracker.habits[k].color;
											// Half circle case
											if(this.habit_tracker.num_habits === 2) {
												let slice_theta_half = slice_theta/2;
												gen.new_layer(null, 0, 0);
												gen.add_slice(null, 0, 0, date_radius-0.5, k*slice_theta, slice_theta_half, 
												{'fill': habit_color});
												gen.add_slice(null, 0, 0, date_radius-0.5, k*slice_theta+slice_theta_half, slice_theta_half, 
												{'fill': habit_color});
												gen.end_layer();
											}
											// All other slice cases
											else {
												gen.add_slice(null, 0, 0, date_radius-0.5, k*slice_theta, slice_theta, 
												{'fill': habit_color});
											}
										}
									}
								}
							}

							// Draw circle and text
							gen.add_circle(null, 0, 0, date_radius, 
								{'stroke': 'black', 'stroke-width': 2});
							gen.add_text(null, 0, 0, cur_date, {'fill': 'black', 'text-anchor': 'middle', 'alignment-baseline': 'central'})
						gen.end_layer();

						j += 1;
						cur_date += 1;
					}
					gen.end_layer();
				}
			}
		}
	</script>

	<!-- Main -->
	<script type="text/javascript">
		$(document).ready(function() {
			let gen = new SvgGenerator('calendar', 1200, 800);

			/*gen.new_layer('dates', 100, 100, {
				'fill': 'transparent', 
				'stroke': '#000',
				'stroke-width': 2,
			});
				gen.add_circle(null, 50, 50, 40);
				gen.new_layer(null, 50, 50);
					gen.add_circle(null, 0, 0, 20);
					gen.end_layer();
				gen.new_layer(null, 80, 80);
					gen.new_layer(null, 0, 0, {'stroke': 'transparent'})
						gen.add_slice(null, 0, 0, 99.5, 0, Math.PI*2/3, {'fill': 'cyan'});
						gen.add_slice(null, 0, 0, 99.5, Math.PI*2/3, Math.PI*2/3, {'fill': 'orange'});
						gen.add_slice(null, 0, 0, 99.5, Math.PI*4/3, Math.PI*2/3, {'fill': 'green'});
						gen.end_layer();
					gen.add_circle(null, 0, 0, 100);
					gen.add_circle(null, 0, 0, 24, {'fill': 'white', 'stroke': 'transparent'});
					gen.add_text(null, 0, 0, '01', {'fill': 'black', 'stroke-width': 0, 'text-anchor': 'middle', 'alignment-baseline': 'central'});
			gen.flush();*/

			let habit_tracker = new HabitTracker();
			let calendar = new Calendar(habit_tracker);

			habit_tracker.add_habit('Brushing', 'Cyan');
			habit_tracker.add_habit('Work', 'Orange');
			habit_tracker.add_habit('Pee', 'Yellow');
			habit_tracker.add_tracked_habit(2019, 2, 21, 1);
			habit_tracker.add_tracked_habit(2019, 2, 21, 0);

			gen.new_layer(null, 10, 10);
			calendar.generate_calendar(gen);
			gen.flush();


			let container = $('#calendarContainer');
			container.append(gen.svg);
		});
	</script>
</body>
</html>